// 这个文件是 MCF 的一部分。
// 有关具体授权说明，请参阅 MCFLicense.txt。
// Copyleft 2012 - 2013. LH_Mouse. All wrongs reserved.

#include "StdMCF.hpp"
#include "Base64Decoder.hpp"
using namespace MCF;

// 静态成员变量。
const BYTE Base64Decoder::xDECODE_TABLE_DRAFT[0x100] = {
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E,
	0x0F, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28,
	0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30, 0x31, 0x32, 0x33, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
};

// 构造函数和析构函数。
Base64Decoder::Base64Decoder(const PARAMS &Params){
	std::memcpy(xm_abyDecodeTable, xDECODE_TABLE_DRAFT, sizeof(xm_abyDecodeTable));
	xm_abyDecodeTable[Params.ch63rd] = 0x3E;
	xm_abyDecodeTable[Params.ch64th] = 0x3F;

	xm_eState = INIT;
}
Base64Decoder::~Base64Decoder(){
}

// 其他非静态成员函数。
void Base64Decoder::xInitialize(void *pOutput){
	UNREF_PARAM(pOutput);
}
void Base64Decoder::xUpdate(void *pOutput, const BYTE *pbyData, std::size_t uSize){
	std::vector<BYTE> &vecOutput = *((std::vector<BYTE> *)pOutput);

	const BYTE *const pbyEnd = pbyData + (std::ptrdiff_t)uSize;
	for(const BYTE *pbyCur = pbyData; pbyCur < pbyEnd; ++pbyCur){
		const BYTE byDecoded = xm_abyDecodeTable[*pbyCur];
		if(byDecoded != 0xFF){
			switch(xm_eState){
				case INIT:
					xm_dwHistory = ((DWORD)byDecoded) << 18;

					xm_eState = BYTE_1;
					break;
				case BYTE_1:
					xm_dwHistory |= ((DWORD)byDecoded) << 12;

					xm_eState = BYTE_2;
					break;
				case BYTE_2:
					xm_dwHistory |= ((DWORD)byDecoded) << 6;

					xm_eState = BYTE_3;
					break;
				case BYTE_3:
					xm_dwHistory |= ((DWORD)byDecoded);
					vecOutput.emplace_back((BYTE)((xm_dwHistory >> 16) & 0xFF));
					vecOutput.emplace_back((BYTE)((xm_dwHistory >> 8) & 0xFF));
					vecOutput.emplace_back((BYTE)(xm_dwHistory & 0xFF));

					xm_eState = INIT;
					break;
				default:
					ASSERT(false);
			}
		}
	}
}
void Base64Decoder::xFinalize(void *pOutput){
	std::vector<BYTE> &vecOutput = *((std::vector<BYTE> *)pOutput);

	switch(xm_eState){
		case INIT:
		case BYTE_1:
			break;
		case BYTE_2:
			vecOutput.emplace_back((BYTE)((xm_dwHistory >> 16) & 0xFF));
			break;
		case BYTE_3:
			vecOutput.emplace_back((BYTE)((xm_dwHistory >> 16) & 0xFF));
			vecOutput.emplace_back((BYTE)((xm_dwHistory >> 8) & 0xFF));
			break;
		default:
			ASSERT(false);
	}
}

void Base64Decoder::Transform(std::vector<BYTE> *pvecOutput, const BYTE *pbyData, std::size_t uSize, bool bIsEndOfStream){
	pvecOutput->reserve(pvecOutput->size() + (uSize + 3) / 4 * 3);

	AbstractTransformerBaseClass::xTransform(pvecOutput, pbyData, uSize, bIsEndOfStream);
}
